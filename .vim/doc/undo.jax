*undo.txt*      For Vim バージョン 6.3.  Last change: 2003 Oct 21


		  VIM REFERENCE MANUAL    by Bram Moolenaar


undo と redo						*undo-redo*

基本的なことは|02.5|で説明されている。

1. undo と redo コマンド	|undo-commands|
2. 2つの undo			|undo-two-ways|
3. undo についての解説		|undo-remarks|

==============================================================================
1. undo と redo コマンド				*undo-commands*

<Undo>		or					*undo* *<Undo>* *u*
u			undo [回数] 変更。  {Vi: 一度のみ}

							*:u* *:un* *:undo*
:u[ndo] 		undo 一度変更.  {Vi: 一度のみ}

							*CTRL-R*
CTRL-R			undo してしまった後 変更 [回数] を redo する。
			{Vi: 再描画}

							*:red* *:redo* *redo*
:red[o]			undo してしまった後一度の変更を redo する。
			{Vi: redo はない}

							*U*
U			行中のすべての最新変更を undo する。  {Vi: その行から
			動かない間}

最後の変更は憶えられている。あなたは Undo と Redo コマンド上で、それぞれ
変更する前にテキストを戻すのに使える。あなたはその上もう一度の変更を適用
することができ、Undo の前にテキストを元に戻すことができる。

"U" コマンドは undo/redo することによって、ちょうどその他のコマンドのように
扱われる。このように、"u" コマンドは Undo であり "U" コマンドと 'CTRL-R'
コマンドは redo だ。 "U", "u" と 'CTRL-R' を混同すると、あなたは "U"
コマンドが以前の "U" コマンドを実行する前の一行の状態に戻すことに気づく
だろう。これは混乱することかもしれしない。慣れてしまうのに練習してほしい。
"U" コマンドは変更したとして、いつもバッファをマークしているだろう。その時
"U" はどのように変更なくすのに、バックバッファを変更する方法は、まだよく考えて
変更されている。
Undo するのに バッファの変更が無くなるまで "u" を使いなさい。

==============================================================================
2. 2つの undo						*undo-two-ways*

どんな undo と redo コマンドは 'cpoptions' 内の 'u' フラグに依存している。
Vim の方法 ('u' 含まない) と Vi 互換の方法 ('u' 含む) がある。
Vim の方法、"uu" は2度の変更を undo する。Vi 互換の方法, "uu" は何もしない
(undo を undo する)

'u' 含まない, Vim の方法:
あなたは undo コマンドで時間をさかのぼれる。その時、redo コマンドでまた前に
進むことができる。あなたは undo コマンドの後に新しい変更を加えた場合、
redo はこれ以上できなくなるだろう。

'u' 含む, Vi 互換の方法:
undo コマンドは 前の変更を undo する。そして、前の undo コマンドもだ。
redo コマンドは以前の undo コマンドを繰り返す。それは変更コマンドを
繰り返さないので、"." を使いなさい。

例		Vim の方法		Vi 互換の方法 ~
"uu"		2回 undo		何もしない
"u CTRL-R"	何もしない		2回 undo

原理:	    Nvi は CTRL-R 代わりに "." コマンドを使用する。あいにく、これは
	    Vi 互換ではない。例えば "dwdwu." Vi では 2単語削除する。
	    Nvi では何もしない。

==============================================================================
3. undo についての解説					*undo-remarks*

記録されている変更数は 'undolevels' オプションでセットされている。
それがゼロの場合、Vi 互換の方法は常に使用される。できなければ undo
なしは可能なことだ。あなたはメモリが足りない場合これを使いなさい。

バッファ ('a から 'z) に関するマークはテキストと共に同様に保存修正されている。
{Vi これは些細な違い}

すべての変更を undo してしまった時、バッファは変更されたとはみなさない。
その時 ":q!" の代わりに :q" で Vim を終了することができる。{これは vi には
ない} Note これはファイルの最終書き込みと比較する。 ":w" の後に "u" を
タイプすることはバッファを実際に変更し、何が書かれたか比較をし、それで
バッファはその時変更されたとみなす。

|folding|をマニュアルで使っている時、フォールドは保存されないし復元もされな
い。フォールドの最初の行と最後の行が変更されないならフォールドは保たれる。

割り振られたレジスタは undo しながら削除する使われ方もできる。 いつもあなたは
テキストを削除し、レジスタ "1 に挿入する。レジスタ "1 の内容は "2 にシフトし
, ete。レジスタ "9 の内容は失しなわれる。あなたはコマンド '"1P' で
一番新しい削除したテキストを今戻すことができる。 (同様に、削除した
テキストが最後の削除またはコピー作業の結果である場合、'P' または 'p'もまた
これは名無レジスタの内容を挿入するように働く)。あなたは、'"3P' で 3回削除
する前のテキストに戻すことができる。

						*redo-register*
あなたは削除したテキストの一部より多く戻したい場合、あなたは繰り返しコマンド
 "." の特別な機能を使用できる。それはレジスタ使用量を増やすだろう。
それで、あなたは最初の ""1P" にしたい場合、"." に従うことは '"2P' の結果となる
だろう。これを繰り返すことはすべての割り振られたレジスタは書き込ませる結果なる
だろう。

例:		あなたは 'dd....' でテキストを削除する場合、それは '1P....' で
		もどすことができる。

あなたはどのレジスターが削除されたテキストかわからない場合、あなたは
:display コマンドが使える。選択すべきことは '"1P'で最初のレジスターを
試すのに、 それと 'u' をしたいのではない場合だ。これは、最初の内容を削除し、
それとセカンドレジスターに関するプットコマンドを繰り返す。あなたのほしい
結果が得られるまで、 'u' を繰り返しなさい。

 vim:tw=78:ts=8:ft=help:norl:
